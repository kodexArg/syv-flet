# Flet Architecture - SyV-Flet

**Version:** 1.0
**Date:** January 16, 2026
**Stack:** Python 3.12+ + Flet + uv
**Level:** Architects and Developers

---

## 1. Architecture Vision

SyV-Flet is a monolithic Flet application that **strictly separates** business logic (game engine) from the presentation layer (Flet interface).

### Fundamental Principles

- **UI Agnostic:** Game engine must NOT import or depend on Flet
- **Explicit Reactivity:** Game state observable from presentation layers
- **Declarative Components:** Interface built with hierarchical `ft.Control`
- **Performance:** Efficient use of `flet.canvas` and update batching
- **Multiplatform:** Same codebase for Desktop (Linux/Windows) and Mobile (Android)

---

## 2. Project Structure

```
syv-flet/
├── pyproject.toml              ← Project configuration (uv)
├── uv.lock                      ← Lock file (generated by uv)
├── README.md
├── PRD.md
│
├── .claude/                     ← Documentation for Claude Code
│   ├── CLAUDE.md                ← Project instructions
│   └── docs/
│       ├── 01-architecture.md   ← This file
│       ├── 02-development.md    ← Development commands
│       └── about-hexagonal-coordinates.md
│
├── src/                         ← Main source code
│   └── syv-flet/
│       ├── __init__.py
│       ├── main.py              ← Entry point (ft.run(main))
│       │
│       ├── engine/              ← Business logic (FLET-AGNOSTIC)
│       │   ├── __init__.py
│       │   ├── board.py         ← Hexagonal board
│       │   ├── units.py         ← Entities (Unit, Officer, Captain)
│       │   ├── orders.py        ← Orders and resolution
│       │   ├── combat.py        ← Combat mechanics
│       │   ├── compass.py       ← Compass logic
│       │   └── state.py         ← Global game state
│       │
│       ├── ui/                  ← Flet interface (Presentation)
│       │   ├── __init__.py
│       │   ├── app.py           ← Main application (Page setup)
│       │   │
│       │   ├── screens/         ← Main screens/views
│       │   │   ├── __init__.py
│       │   │   ├── game_screen.py     ← Game screen (board)
│       │   │   └── menu_screen.py     ← Main menu
│       │   │
│       │   ├── components/      ← Reusable components
│       │   │   ├── __init__.py
│       │   │   ├── hex_grid.py        ← Hexagonal grid widget
│       │   │   ├── compass_widget.py  ← Compass widget
│       │   │   ├── unit_sprite.py     ← Unit visual representation
│       │   │   └── order_panel.py     ← Orders panel
│       │   │
│       │   ├── controllers/     ← Controller logic (Bridge)
│       │   │   ├── __init__.py
│       │   │   ├── game_controller.py ← Coordinates UI ↔ Engine
│       │   │   └── input_handler.py   ← Gestures and input
│       │   │
│       │   ├── models/          ← Observable models (State binding)
│       │   │   ├── __init__.py
│       │   │   ├── game_state_ui.py   ← Observable mirror of engine state
│       │   │   └── observers.py       ← Observer pattern for reactivity
│       │   │
│       │   └── styles/          ← Themes, colors, fonts
│       │       ├── __init__.py
│       │       ├── colors.py
│       │       └── theme.py
│       │
│       └── utils/               ← Shared utilities
│           ├── __init__.py
│           ├── logger.py        ← Logging
│           └── geometry.py      ← Math helpers (pixel↔hex)
│
├── tests/                       ← Unit tests
│   ├── __init__.py
│   ├── test_board.py
│   ├── test_units.py
│   ├── test_combat.py
│   └── test_geometry.py
│
└── assets/                      ← Static resources
    ├── images/
    │   ├── compass_dial.png
    │   ├── compass_needle.png
    │   └── unit_sprites/
    ├── fonts/
    └── sounds/ (future)
```

---

## 3. Layered Architecture

### 3.1. Engine Layer - FLET-AGNOSTIC

**Responsibility:** Pure game logic. No Flet dependencies.

**Key Modules:**

```python
# src/syv-flet/engine/board.py
class Board:
    """Hexagonal board with O(1) coordinate lookup."""
    def __init__(self, radius: int = 20):
        self.radius = radius
        self.hexes = {}  # {(q, r): HexData}

    def is_valid(self, q: int, r: int) -> bool:
        """Check if (q,r) is within board bounds."""
        ...

    def neighbors(self, q: int, r: int) -> list[tuple[int, int]]:
        """Return 6 adjacent hexagons."""
        ...

    def distance(self, a: tuple, b: tuple) -> int:
        """Hexagonal Manhattan distance."""
        ...

# src/syv-flet/engine/units.py
class Unit:
    """Military unit entity (Infantry, Officer, Captain)."""
    def __init__(self, id: str, faction: str, type: UnitType, pos: tuple[int, int]):
        self.id = id
        self.faction = faction
        self.type = type
        self.position = pos
        self.state = UnitState.ACTIVE
        self.health = 100

    def take_damage(self, amount: int) -> None:
        """Reduce health, change state if necessary."""
        ...

# src/syv-flet/engine/state.py (Pattern: State Machine)
class GameState:
    """Global game state (UI-agnostic)."""
    def __init__(self, board: Board):
        self.board = board
        self.units = {}  # {unit_id: Unit}
        self.turn = 0
        self.phase = GamePhase.ORDER_INPUT
        self.observers = []  # To notify changes to UI

    def add_observer(self, callback: Callable) -> None:
        """Observer pattern: UI subscribes to changes."""
        self.observers.append(callback)

    def notify_observers(self, event: GameEvent) -> None:
        """Notify all observers."""
        for callback in self.observers:
            callback(event)

    def process_turn(self) -> None:
        """Resolve all orders simultaneously."""
        # Movement → Collisions → Combat → Cleanup
        ...
```

**Characteristics:**

- ✅ Testeable: No UI dependencies
- ✅ Reusable: Could be used in CLI, server, etc.
- ✅ Observable: Emits events when state changes
- ✅ Deterministic: Same input → Same output

### 3.2. Presentation Layer - Flet

**Responsibility:** Visual rendering and user input.

**Patterns:**

#### **Model 1: Hierarchical Page and Stack**

```python
# src/syv-flet/ui/app.py
import flet as ft
from syv-flet.ui.screens import GameScreen

def main(page: ft.Page):
    """Flet application entry point."""
    page.title = "SyV-Flet"
    page.window_width = 1280
    page.window_height = 720
    page.theme_mode = ft.ThemeMode.DARK

    # Screen navigation
    def navigate_to_game():
        page.clean()
        game_screen = GameScreen(page)
        page.add(game_screen)

    # Main menu
    menu_btn = ft.FilledButton("Start Game", on_click=lambda _: navigate_to_game())
    page.add(
        ft.Column([
            ft.Text("SyV-Flet", size=40, weight="bold"),
            menu_btn
        ])
    )

if __name__ == "__main__":
    ft.run(main, assets_dir="assets")
```

#### **Model 2: Reusable Components**

```python
# src/syv-flet/ui/components/hex_grid.py
import flet as ft
from flet import canvas as cv

class HexGridWidget(ft.Stack):
    """Hexagonal grid widget with static canvas and dynamic objects."""

    def __init__(self, board, hex_size: int = 40, on_hex_click=None):
        super().__init__()
        self.board = board
        self.hex_size = hex_size
        self.on_hex_click = on_hex_click

        # Canvas for static mesh (drawn once)
        self.grid_canvas = cv.Canvas(
            shapes=[self._draw_grid()],
            width=1200,
            height=600
        )

        # Transparent GestureDetector for input
        self.gesture_layer = ft.GestureDetector(
            on_tap=self._on_tap,
            mouse_region=True,
        )

        # Container for unit sprites (dynamic)
        self.units_container = ft.Stack()

        self.controls = [self.grid_canvas, self.units_container, self.gesture_layer]

    def _draw_grid(self) -> cv.Path:
        """Draw all board hexagons (once only)."""
        paths = []
        for q in range(-self.board.radius, self.board.radius + 1):
            for r in range(...):  # See about-hexagonal-coordinates.md
                x, y = self._hex_to_pixel(q, r)
                hex_path = self._create_hex_path(x, y, self.hex_size)
                paths.append(hex_path)
        return paths

    def _on_tap(self, e: ft.TapEvent):
        """Convert pixels to hexagonal coordinates."""
        q, r = self._pixel_to_hex(e.local_x, e.local_y)
        if self.on_hex_click:
            self.on_hex_click(q, r)

    def update_unit_position(self, unit_id: str, new_q: int, new_r: int):
        """Update unit's visual position."""
        x, y = self._hex_to_pixel(new_q, new_r)
        # Animate unit sprite to new position
        self.units_container.controls[unit_id].animate_position(x, y)
```

#### **Model 3: Controllers (Bridge Pattern)**

```python
# src/syv-flet/ui/controllers/game_controller.py
from syv-flet.engine.state import GameState

class GameController:
    """Coordinates communication between Engine ↔ UI."""

    def __init__(self, engine_state: GameState, ui_refs: dict):
        self.engine = engine_state
        self.ui = ui_refs  # References to Flet widgets

        # Subscribe to engine changes
        self.engine.add_observer(self._on_engine_event)

    def _on_engine_event(self, event):
        """Callback when engine state changes."""
        if event.type == "unit_moved":
            self.ui["hex_grid"].update_unit_position(
                event.unit_id, event.new_q, event.new_r
            )
        elif event.type == "combat_resolved":
            self.ui["combat_log"].add_entry(event.log_message)

    def on_hex_selected(self, q: int, r: int):
        """User clicks hexagon."""
        # 1. Validate in engine
        unit = self.engine.get_unit_at(q, r)
        if not unit:
            return

        # 2. Show options in UI
        self.ui["order_panel"].show_order_menu(unit, (q, r))

    def submit_order(self, unit_id: str, order_type: str, target: tuple):
        """User confirms order."""
        # 1. Process in engine
        self.engine.add_order(unit_id, order_type, target)

        # 2. Update UI
        self.ui["order_panel"].hide()
```

### 3.3. Observable Models Layer - UI State Binding

**Responsibility:** Observable mirror of engine state. Notifies Flet of changes.

```python
# src/syv-flet/ui/models/game_state_ui.py
from typing import Callable

class GameStateUI:
    """Observable wrapper of engine state."""

    def __init__(self, engine_state):
        self.engine = engine_state
        self._listeners: list[Callable] = []
        self._current_selected_hex = None

    def subscribe(self, callback: Callable) -> None:
        """Subscribe to state changes."""
        self._listeners.append(callback)

    def notify(self, change: dict) -> None:
        """Notify all listeners."""
        for listener in self._listeners:
            listener(change)

    @property
    def selected_hex(self):
        return self._current_selected_hex

    @selected_hex.setter
    def selected_hex(self, value):
        if self._current_selected_hex != value:
            self._current_selected_hex = value
            self.notify({"type": "hex_selected", "hex": value})
```

---

## 4. Data Flow

```
FLET UI
   ↓ (on_tap / on_click)
USER INPUT
   ↓
GameController.on_hex_selected(q, r)
   ↓
Engine.process_order()
   ↓
Engine.notify_observers(GameEvent)
   ↓
GameStateUI._listeners callback
   ↓
HexGrid.update_unit_position()
   ↓
VISUAL UPDATE (Canvas/Sprite animation)
```

**Key Feature:** UI never directly modifies engine. Everything goes through controllers and events.

---

## 5. Main Flet Components

### 5.1. Layout - [Docs](https://docs.flet.dev/controls/page)

| Control | Use in SyV-Flet | Reference |
|---------|---------------|-----------|
| `ft.Page` | Root container of application | [Page](https://docs.flet.dev/controls/page) |
| `ft.Stack` | Grid, terrain, units layers | [Stack](https://docs.flet.dev/controls/stack) |
| `ft.Column` / `ft.Row` | Side panels (orders, UI) | [Column](https://docs.flet.dev/controls/column), [Row](https://docs.flet.dev/controls/row) |
| `ft.Container` | Backgrounds, borders, positioning | [Container](https://docs.flet.dev/controls/container) |
| `ft.GridView` | Future: unit arsenal grid | [GridView](https://docs.flet.dev/controls/gridview) |

### 5.2. Rendering - [Canvas Docs](https://docs.flet.dev/controls/canvas)

```python
from flet import canvas as cv

# Draw static hexagons
canvas = cv.Canvas(
    shapes=[
        cv.Path(
            data="M 100,50 L 150,25 L 200,50 L 200,100 L 150,125 L 100,100 Z",
            stroke="black",
            fill="white"
        )
    ]
)
```

| Shape | Use |
|-------|-----|
| `cv.Path` | Hexagon polygons |
| `cv.Circle` | Units, hotspots |
| `cv.Line` | Movement lines, attacks |
| `cv.Text` | Hex labels (unit count) |

### 5.3. Input and Gestures - [Docs](https://docs.flet.dev/controls/gesturedetector)

```python
# Detector for board clicks
gesture = ft.GestureDetector(
    on_tap=lambda e: handle_click(e.local_x, e.local_y),
    on_tap_down=lambda e: handle_hover(e),
    mouse_region=True
)

# In event handlers:
# e.local_x, e.local_y = coordinates relative to widget
# Needed for pixel → (q, r) conversion
```

### 5.4. Animations - [Docs](https://docs.flet.dev/controls/animatedcontainer)

```python
# Compass: smooth rotation
from flet import transform as ft_transform

needle = ft.Image(src="compass_needle.png")
needle.rotate = ft_transform.Rotate(angle=0)
needle.animate_rotation(angle=math.radians(angle), duration_ms=800)

# Units: smooth movement
unit_sprite = ft.Container()
unit_sprite.animate_offset(offset_x=new_x, offset_y=new_y, duration_ms=500)
```

### 5.5. Images and Assets - [Docs](https://docs.flet.dev/controls/image)

```python
# In main():
ft.run(main, assets_dir="assets")

# In component:
compass_dial = ft.Image(
    src="compass_dial.png",
    width=200,
    height=200
)
```

---

## 6. Flet Best Practices for SyV-Flet

### 6.1. Separation of Concerns

❌ **BAD:**
```python
def on_hex_click(e):
    # Mixes game logic with UI
    units[selected_unit].position = (q, r)
    page.add(ft.Text("Moved"))
```

✅ **GOOD:**
```python
def on_hex_click(e):
    # UI only
    q, r = pixel_to_hex(e.local_x, e.local_y)
    controller.on_hex_selected(q, r)

# In controller:
def on_hex_selected(self, q, r):
    # Engine makes changes
    self.engine.move_unit(unit_id, (q, r))
    # UI reacts to engine event
```

### 6.2. Performance

- **Static Canvas:** Draw grid once. Don't redraw every frame.
- **Dynamic Containers:** Move `ft.Container` over static canvas (faster than redrawing)
- **Batch Updates:** Group changes: `page.update()` at end, not after each widget

```python
# Update multiple units
for unit in updated_units:
    update_unit_visual(unit)

page.update()  # Single call
```

### 6.3. Responsive Design

```python
def main(page: ft.Page):
    page.on_window_event = lambda e: handle_resize(e)

    def handle_resize(e):
        if page.window_width < 800:
            # Mobile layout
            layout.horizontal = False
        else:
            # Desktop layout
            layout.horizontal = True
        page.update()
```

### 6.4. Testing

Engine (without Flet):
```python
# tests/test_combat.py
def test_combat_deterministic():
    engine = GameState()
    result = engine.resolve_combat(unit_a, unit_b, force_a=10, force_b=10)
    assert result.winner == expected_winner
```

UI (with Flet mock):
```python
# tests/test_ui_controller.py
def test_controller_updates_ui():
    mock_ui = {"hex_grid": MagicMock()}
    controller = GameController(engine, mock_ui)
    engine.move_unit(...)
    mock_ui["hex_grid"].update_unit_position.assert_called()
```

---

## 7. Configuration with `uv` and `pyproject.toml`

### 7.1. `pyproject.toml` Structure

```toml
[project]
name = "syv-flet"
version = "0.1.0"
description = "Hexagonal strategy game in Python + Flet"
authors = [{name = "Team SyV-Flet"}]
requires-python = ">=3.12"

dependencies = [
    "flet>=0.24.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "pytest-cov>=4.0",
    "black>=23.0",
    "ruff>=0.1.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.uv]
python-version = "3.12"

[tool.pytest.ini_options]
testpaths = ["tests"]
```

### 7.2. Common `uv` Commands

See **02-development.md** for complete list.

---

## 8. Official Flet Documentation References

### Topic Index

| Topic | Link | SyV-Flet Relevance |
|-------|------|-----------------|
| Getting Started | [docs.flet.dev/guides/python/getting-started](https://docs.flet.dev/guides/python/getting-started) | ✅ Project foundation |
| Controls Reference | [docs.flet.dev/controls](https://docs.flet.dev/controls) | ✅ Stack, Container, Canvas |
| Canvas | [docs.flet.dev/controls/canvas](https://docs.flet.dev/controls/canvas) | ✅✅ CRITICAL for hex grid |
| GestureDetector | [docs.flet.dev/controls/gesturedetector](https://docs.flet.dev/controls/gesturedetector) | ✅✅ User input |
| Animations | [docs.flet.dev/controls/animatedcontainer](https://docs.flet.dev/controls/animatedcontainer) | ✅ Unit movement, compass |
| Image | [docs.flet.dev/controls/image](https://docs.flet.dev/controls/image) | ✅ Sprites, assets |
| Publishing | [docs.flet.dev/guides/publishing](https://docs.flet.dev/guides/publishing) | ⏳ After MVP |
| Troubleshooting | [docs.flet.dev/troubleshooting](https://docs.flet.dev/troubleshooting) | ✅ Debug common issues |

### Relevant Tutorials

- **To Do App**: [docs.flet.dev/tutorials/todo](https://docs.flet.dev/tutorials/todo) — Basic state management
- **Counter**: [docs.flet.dev/tutorials/counter](https://docs.flet.dev/tutorials/counter) — Event handling

---

## 9. Quick Actions and Commands

### Local Development

```bash
# Install dependencies (in project)
uv sync

# Run application with hot reload
uv run python -m syv-flet.main

# Run tests
uv run pytest

# Format code
uv run black src/ tests/

# Linter
uv run ruff check src/ tests/
```

### Debugging

```bash
# Verbose logging
FLET_DEBUG=1 uv run python -m syv-flet.main

# Python debugger in VS Code:
# Add .vscode/launch.json (see 02-development.md)
```

### Build/Packaging

```bash
# Build for Linux (AppImage)
flet build linux --include-packages syv-flet

# Build for Android (APK)
flet build apk --app-version 0.1.0
```

---

## 10. Implementation Checklist

- [ ] Create folder structure (`src/syv-flet/engine/`, `ui/`, etc.)
- [ ] Implement `engine/board.py` and tests
- [ ] Implement `engine/units.py` and `engine/combat.py`
- [ ] Create `ui/app.py` with Flet entry point
- [ ] Implement `ui/components/hex_grid.py` (static canvas)
- [ ] Create `ui/controllers/game_controller.py` (bridge)
- [ ] Implement event system (observers)
- [ ] Validate rendering @ 60 FPS
- [ ] Controller tests (mocking Flet)
- [ ] Build/packaging CI/CD

---

**NEXT STEP:** See [02-development.md](./02-development.md) for terminal flow and commands.
